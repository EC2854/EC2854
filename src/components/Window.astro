---
const { name, id } = Astro.props;
---
<div id={id} class="window opacity-0 pointer-events-none fixed top-[100px] left-[100px] w-[800px] h-[480px] border-2 border-[var(--window-outline)] shadow-black shadow-md/30 flex [&.visible]:pointer-events-auto [&.visible]:opacity-100">
  <div class="flex flex-col flex-grow h-full box-border border-6 border-[var(--window-border)]">
    <header class="border-b-6 border-[var(--window-border)] cursor-move">
      <div class="flex items-center justify-start bg-gradient-to-r from-[var(--window-header)] to-[var(--window-header-light)] border-2 border-[var(--window-outline)] text-[var(--fg)] px-2 py-1 font-semibold select-none">
        <h1 class="text-xl m-0 select-none">{name}</h1>
        <nav class="ml-auto flex items-center">
          <button id={`${id}-maximize`} class="icon ml-2 w-7 h-7 cursor-pointer transition-all shadow-md bg-[var(--maximize)] border-2 border-[var(--maximize-fg)] text-[var(--maximize-fg)] hover:bg-[var(--maximize-pressed)] hover:border-[var(--maximize-fg-pressed)] hover:text-[var(--maximize-fg-pressed)] hover:animate-[tiltBounce_0.5s_ease_forwards]">
            fullscreen
          </button>
          <button id={`${id}-close`} class="icon ml-2 w-7 h-7 cursor-pointer transition-all shadow-md bg-[var(--close)] border-2 border-[var(--close-fg)] text-[var(--close-fg)] hover:bg-[var(--close-pressed)] hover:border-[var(--close-fg-pressed)] hover:text-[var(--close-fg-pressed)] hover:animate-[tiltBounce_0.5s_ease_forwards]">
            close
          </button>
        </nav>
      </div>
    </header>
    <section class="flex flex-1 border-2 border-[var(--window-outline)] p-0 bg-[var(--bg)] text-[var(--fg)] h-full w-full box-border min-h-0">
      <slot />
    </section>
  </div>
</div>

<script is:inline define:vars={{ id }}>
    const el = document.getElementById(id);
    const header = el.querySelector('.window > div > header');
    const closeBtn = document.getElementById(`${id}-close`);
    const maximizeBtn = document.getElementById(`${id}-maximize`);

    function setZIndex(className, zIndex) {
        document.querySelectorAll(`div.${className}`).forEach(div => {
            div.style.zIndex = zIndex.toString();
        });
    }

    let isDragging = false;
    let offsetX = 0, offsetY = 0;

    function onMouseDown(e) {
        isDragging = true;
        const rect = el.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        setZIndex("window", 1);
        el.style.zIndex = 2;

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    }

    // Resizing
    let isResizing = false;
    let resizeStartX = 0, resizeStartY = 0;
    let resizeStartWidth = 0, resizeStartHeight = 0;

    const resizer = document.createElement("div");
    Object.assign(resizer.style, {
        width: "20px",
        height: "20px",
        position: "absolute",
        right: "0",
        bottom: "0",
        cursor: "se-resize",
        background: "transparent"
    });
    el.appendChild(resizer);

    resizer.addEventListener("mousedown", (e) => {
        e.stopPropagation();
        isResizing = true;
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        resizeStartWidth = el.offsetWidth;
        resizeStartHeight = el.offsetHeight;

        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
    });

    // Shared mouse move handler
    function onMouseMove(e) {
        if (isDragging) {
            el.style.left = `${e.clientX - offsetX}px`;
            el.style.top = `${e.clientY - offsetY}px`;
        } else if (isResizing) {
            const dx = e.clientX - resizeStartX;
            const dy = e.clientY - resizeStartY;

            const newWidth = resizeStartWidth + dx;
            const newHeight = resizeStartHeight + dy;

            const originalWidth = el.style.width;
            const originalHeight = el.style.height;

            el.style.width = `${newWidth}px`;
            if (el.scrollWidth > el.clientWidth) el.style.width = originalWidth;

            el.style.height = `${newHeight}px`;
            if (el.scrollHeight > el.clientHeight) el.style.height = originalHeight;

        }
        const data = el.dataset;
        data.prevLeft = el.style.left || el.offsetLeft + "px";
        data.prevTop = el.style.top || el.offsetTop + "px";
        data.prevWidth = el.style.width || el.offsetWidth + "px";
        data.prevHeight = el.style.height || el.offsetHeight + "px";
        data.maximized = "false";
    }

    function onMouseUp() {
        isDragging = false;
        isResizing = false;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
    }

    // Close window
    function closeWindow() {
        el.classList.toggle("visible");
    }

    // Maximize / Restore window
    function maximizeWindow() {
        const data = el.dataset;

        if (data.maximized === "true") {
            el.style.left = data.prevLeft || "100px";
            el.style.top = data.prevTop || "100px";
            el.style.width = data.prevWidth || "800px";
            el.style.height = data.prevHeight || "480px";
            data.maximized = "false";
        } else {
            data.prevLeft = el.style.left || el.offsetLeft + "px";
            data.prevTop = el.style.top || el.offsetTop + "px";
            data.prevWidth = el.style.width || el.offsetWidth + "px";
            data.prevHeight = el.style.height || el.offsetHeight + "px";

            el.style.left = "0";
            el.style.top = "0";
            el.style.width = "100vw";
            el.style.height = "calc(100vh - 48px)";
            data.maximized = "true";
        }
    }

    header.addEventListener("mousedown", onMouseDown);
    header.addEventListener("dblclick", maximizeWindow);
    closeBtn.addEventListener("click", closeWindow);
    maximizeBtn.addEventListener("click", maximizeWindow);
</script>
